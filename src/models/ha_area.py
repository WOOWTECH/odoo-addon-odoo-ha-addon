from odoo import models, fields, api
import logging
import json

_logger = logging.getLogger(__name__)


class HAArea(models.Model):
    """Home Assistant Area Model with Bidirectional Sync"""
    _name = 'ha.area'
    _description = 'Home Assistant Area'

    # SQL Constraints
    _sql_constraints = [
        ('area_instance_unique',
         'unique(area_id, ha_instance_id)',
         'Area ID must be unique per HA instance')
    ]

    ha_instance_id = fields.Many2one(
        'ha.instance',
        string='HA Instance',
        required=True,
        index=True,
        ondelete='cascade',
        help='The Home Assistant instance this area belongs to'
    )
    area_id = fields.Char(
        string='Area ID',
        index=True,
        copy=False,
        readonly=True,
        help='Auto-generated by Home Assistant when area is created'
    )
    name = fields.Char(string='Name', required=True)
    aliases = fields.Json(string='Aliases')
    picture = fields.Char(string='Picture')
    icon = fields.Char(string='Icon')
    floor_id = fields.Char(string='Floor ID')
    label_ids = fields.Many2many(
        'ha.label',
        'ha_area_label_rel',
        'area_id',
        'label_id',
        string='Labels',
        domain="[('ha_instance_id', '=', ha_instance_id)]",
        help='Area labels for categorization (synced with HA)'
    )

    # Relational field to entities
    entity_ids = fields.One2many('ha.entity', 'area_id', string='Entities')
    entity_count = fields.Integer(string='Entity Count', compute='_compute_entity_count', store=True)

    @api.depends('entity_ids')
    def _compute_entity_count(self):
        """計算此 area 下的 entity 數量"""
        for area in self:
            area.entity_count = len(area.entity_ids)

    # ========== Bidirectional Sync: Odoo → HA ==========

    @api.model_create_multi
    def create(self, vals_list):
        """
        覆寫 create：建立 Area 後同步到 HA

        使用 context['from_ha_sync'] = True 來防止循環同步
        """
        records = super().create(vals_list)

        # 若是從 HA 同步過來的，不再回傳給 HA（防止循環）
        if not self.env.context.get('from_ha_sync'):
            for record in records:
                try:
                    record._create_area_in_ha()
                except Exception as e:
                    _logger.error(f"Failed to sync area {record.name} to HA: {e}")

        return records

    def write(self, vals):
        """
        覆寫 write：更新 Area 後同步到 HA

        使用 context['from_ha_sync'] = True 來防止循環同步
        """
        result = super().write(vals)

        # 若是從 HA 同步過來的，不再回傳給 HA（防止循環）
        if not self.env.context.get('from_ha_sync'):
            for record in self:
                try:
                    record._update_area_in_ha()
                except Exception as e:
                    _logger.error(f"Failed to sync area update {record.name} to HA: {e}")

        return result

    def unlink(self):
        """
        覆寫 unlink：刪除 Area 前先同步到 HA

        使用 context['from_ha_sync'] = True 來防止循環同步
        """
        # 先備份 area_id 和 instance_id 用於 HA API 呼叫
        areas_to_delete = [(r.area_id, r.ha_instance_id.id, r.name) for r in self]

        result = super().unlink()

        # 若是從 HA 同步過來的，不再回傳給 HA（防止循環）
        if not self.env.context.get('from_ha_sync'):
            for area_id, instance_id, name in areas_to_delete:
                if not area_id:
                    _logger.info(f"Skipping HA delete for area '{name}' - not synced to HA yet")
                    continue
                try:
                    self._delete_area_in_ha(area_id, instance_id)
                except Exception as e:
                    _logger.error(f"Failed to delete area {name} from HA: {e}")

        return result

    def _create_area_in_ha(self):
        """
        在 HA 中建立 Area

        使用 WebSocket API: config/area_registry/create
        """
        self.ensure_one()

        if not self.ha_instance_id:
            _logger.warning(f"Cannot sync area {self.name}: no HA instance")
            return

        try:
            from odoo.addons.odoo_ha_addon.models.common.websocket_client import get_websocket_client
            client = get_websocket_client(self.env, instance_id=self.ha_instance_id.id)

            payload = {
                'name': self.name,
                'labels': self.label_ids.mapped('label_id') if self.label_ids else [],
                'aliases': self.aliases or [],
            }

            _logger.info(f"Creating area in HA: {self.name} (instance {self.ha_instance_id.id})")
            result = client.call_websocket_api_sync('config/area_registry/create', payload)

            if result and isinstance(result, dict):
                # 更新 Odoo 中的 area_id（HA 會產生 area_id）
                ha_area_id = result.get('area_id')
                if ha_area_id and ha_area_id != self.area_id:
                    # 使用 from_ha_sync 避免循環
                    self.with_context(from_ha_sync=True).write({'area_id': ha_area_id})
                    _logger.info(f"Updated area_id from HA: {ha_area_id}")

            _logger.info(f"Area {self.name} created in HA successfully")

        except Exception as e:
            _logger.error(f"Failed to create area {self.name} in HA: {e}", exc_info=True)
            raise

    def _update_area_in_ha(self):
        """
        在 HA 中更新 Area

        使用 WebSocket API: config/area_registry/update
        """
        self.ensure_one()

        if not self.ha_instance_id or not self.area_id:
            _logger.warning(f"Cannot sync area update {self.name}: missing HA instance or area_id")
            return

        try:
            from odoo.addons.odoo_ha_addon.models.common.websocket_client import get_websocket_client
            client = get_websocket_client(self.env, instance_id=self.ha_instance_id.id)

            payload = {
                'area_id': self.area_id,
                'name': self.name,
                'picture': self.picture or None,
                'icon': self.icon or None,
                'floor_id': self.floor_id or None,
                'labels': self.label_ids.mapped('label_id') if self.label_ids else [],
                'aliases': self.aliases or [],
            }

            _logger.info(f"Updating area in HA: {self.name} (area_id={self.area_id})")
            client.call_websocket_api_sync('config/area_registry/update', payload)

            _logger.info(f"Area {self.name} updated in HA successfully")

        except Exception as e:
            _logger.error(f"Failed to update area {self.name} in HA: {e}", exc_info=True)
            raise

    @api.model
    def _delete_area_in_ha(self, area_id, instance_id):
        """
        在 HA 中刪除 Area

        使用 WebSocket API: config/area_registry/delete

        Args:
            area_id: HA 的 area_id
            instance_id: HA 實例 ID
        """
        if not area_id or not instance_id:
            _logger.warning(f"Cannot delete area: missing area_id or instance_id")
            return

        try:
            from odoo.addons.odoo_ha_addon.models.common.websocket_client import get_websocket_client
            client = get_websocket_client(self.env, instance_id=instance_id)

            payload = {'area_id': area_id}

            _logger.info(f"Deleting area in HA: {area_id} (instance {instance_id})")
            client.call_websocket_api_sync('config/area_registry/delete', payload)

            _logger.info(f"Area {area_id} deleted in HA successfully")

        except Exception as e:
            _logger.error(f"Failed to delete area {area_id} in HA: {e}", exc_info=True)
            raise

    # ========== Bidirectional Sync: HA → Odoo ==========

    @api.model
    def sync_area_from_ha_event(self, action, area_id, instance_id):
        """
        處理從 HA WebSocket 事件收到的 Area 變更

        Args:
            action: 'create', 'update', 或 'remove'
            area_id: HA 的 area_id
            instance_id: HA 實例 ID
        """
        _logger.info(f"Processing HA area event: {action} - {area_id} (instance {instance_id})")

        if action == 'remove':
            self._handle_area_remove_from_ha(area_id, instance_id)
        elif action in ('create', 'update'):
            self._handle_area_create_or_update_from_ha(area_id, instance_id)
        else:
            _logger.warning(f"Unknown area action: {action}")

    def _handle_area_remove_from_ha(self, area_id, instance_id):
        """
        處理從 HA 刪除 Area 的事件

        Args:
            area_id: HA 的 area_id
            instance_id: HA 實例 ID
        """
        existing_area = self.search([
            ('area_id', '=', area_id),
            ('ha_instance_id', '=', instance_id)
        ], limit=1)

        if existing_area:
            _logger.info(f"Deleting area from Odoo: {existing_area.name} (area_id={area_id})")
            # 使用 from_ha_sync 防止循環同步
            existing_area.with_context(from_ha_sync=True).unlink()
        else:
            _logger.debug(f"Area {area_id} not found in Odoo, skipping delete")

    def _handle_area_create_or_update_from_ha(self, area_id, instance_id):
        """
        處理從 HA 建立或更新 Area 的事件
        需要呼叫 HA API 取得完整的 Area 資料

        Args:
            area_id: HA 的 area_id
            instance_id: HA 實例 ID
        """
        try:
            from odoo.addons.odoo_ha_addon.models.common.websocket_client import get_websocket_client
            client = get_websocket_client(self.env, instance_id=instance_id)

            # 取得所有 areas 列表（HA 沒有 get single area API）
            result = client.call_websocket_api_sync('config/area_registry/list', {})

            if not result or not isinstance(result, list):
                _logger.warning(f"Failed to get area list from HA")
                return

            # 找到目標 area
            area_data = None
            for area in result:
                if area.get('area_id') == area_id:
                    area_data = area
                    break

            if not area_data:
                _logger.warning(f"Area {area_id} not found in HA area list")
                return

            # 同步到 Odoo
            self._sync_single_area_from_ha(area_data, instance_id)

        except Exception as e:
            _logger.error(f"Failed to sync area from HA event: {e}", exc_info=True)

    @api.model
    def sync_area_from_ha_data(self, area_data, instance_id):
        """
        統一方法：從 HA 資料同步單一 Area 到 Odoo

        這是 HA → Odoo 同步的唯一入口點，被以下方法呼叫：
        - WebSocket 事件處理
        - 初始同步（批次）
        - 手動同步

        Args:
            area_data: HA 回傳的 area 資料 dict
            instance_id: HA 實例 ID

        Returns:
            tuple: (action, area_record) - action 為 'created', 'updated' 或 None
        """
        area_id = area_data.get('area_id')
        if not area_id:
            return None, None

        # Convert HA labels (string array) to Odoo label_ids (Many2many)
        ha_labels = area_data.get('labels', [])
        label_records = self.env['ha.label'].get_or_create_labels(ha_labels, instance_id)

        values = {
            'area_id': area_id,
            'name': area_data.get('name', ''),
            'aliases': area_data.get('aliases', []),
            'picture': area_data.get('picture'),
            'icon': area_data.get('icon'),
            'floor_id': area_data.get('floor_id'),
            'label_ids': [(6, 0, label_records.ids)],  # Replace all labels
            'ha_instance_id': instance_id,
        }

        existing_area = self.sudo().search([
            ('area_id', '=', area_id),
            ('ha_instance_id', '=', instance_id)
        ], limit=1)

        # 使用 from_ha_sync 防止循環同步
        if existing_area:
            existing_area.with_context(from_ha_sync=True).write(values)
            return 'updated', existing_area
        else:
            new_area = self.sudo().with_context(from_ha_sync=True).create(values)
            return 'created', new_area

    def _sync_single_area_from_ha(self, area_data, instance_id):
        """
        從 HA 同步單一 Area 到 Odoo（內部呼叫統一方法）

        Args:
            area_data: HA 回傳的 area 資料
            instance_id: HA 實例 ID
        """
        action, area = self.sync_area_from_ha_data(area_data, instance_id)
        if action and area:
            _logger.info(f"{action.capitalize()} area from HA: {area.name} (area_id={area.area_id})")

    @api.model
    def sync_areas_from_ha(self, instance_id=None):
        """
        從 Home Assistant 同步所有 areas
        使用 WebSocket API 的 config/area_registry/list 指令
        參考: PDF 文檔 page 25-26

        Args:
            instance_id: HA 實例 ID (Phase 3 & 3.1)，如果為 None 則使用 HAInstanceHelper
        """
        _logger.info(f"=== Starting sync_areas_from_ha (instance_id={instance_id}) ===")

        try:
            # Phase 3.1: 使用 HAInstanceHelper 統一獲取實例 ID（重構後）
            if instance_id is None:
                from odoo.addons.odoo_ha_addon.models.common.instance_helper import HAInstanceHelper
                instance_id = HAInstanceHelper.get_current_instance(self.env, logger=_logger)
                if not instance_id:
                    _logger.error("No HA instance available")
                    return

            # 創建 WebSocket client（傳入明確的 instance_id）
            from odoo.addons.odoo_ha_addon.models.common.websocket_client import get_websocket_client
            client = get_websocket_client(self.env, instance_id=instance_id)

            # 根據 PDF 文檔，使用正確的 message type
            result = client.call_websocket_api_sync('config/area_registry/list', {})

            if not result or not isinstance(result, list):
                _logger.warning("No areas received from Home Assistant or invalid format")
                _logger.debug(f"Received result: {result}")
                return

            _logger.info(f"Received {len(result)} areas from Home Assistant (instance {instance_id})")

            # Phase 3: 批次處理 areas，傳入 instance_id
            self._batch_update_areas(result, instance_id)

            _logger.info("=== sync_areas_from_ha completed ===")

        except Exception as e:
            _logger.error(f"Failed to sync areas: {e}", exc_info=True)

    def _batch_update_areas(self, areas_data, instance_id):
        """
        批次更新 area 記錄

        使用 sync_area_from_ha_data 統一方法

        Args:
            areas_data: HA 回傳的 area 資料列表
            instance_id: HA 實例 ID (Phase 3)
        """
        created_count = 0
        updated_count = 0

        for area_data in areas_data:
            try:
                action, _ = self.sync_area_from_ha_data(area_data, instance_id)
                if action == 'created':
                    created_count += 1
                elif action == 'updated':
                    updated_count += 1

            except Exception as e:
                _logger.error(f"Error processing area {area_data.get('area_id')}: {e}")

        _logger.info(f"Area sync (instance {instance_id}): {created_count} created, {updated_count} updated")
