from odoo import models, fields, api
from odoo.exceptions import AccessError
import logging

_logger = logging.getLogger(__name__)


class HALabel(models.Model):
    """Home Assistant Label Model with Bidirectional Sync

    Labels are shared across devices and areas within the same HA instance.
    This model syncs bidirectionally with HA's label registry.

    HA Label Registry API:
    - config/label_registry/list
    - config/label_registry/create
    - config/label_registry/update
    - config/label_registry/delete
    - label_registry_updated (event)
    """
    _name = 'ha.label'
    _description = 'Home Assistant Label'
    _order = 'name'

    _sql_constraints = [
        ('label_instance_unique', 'unique(label_id, ha_instance_id)',
         'Label ID must be unique per HA instance')
    ]

    # HA Label Registry fields
    label_id = fields.Char(
        string='Label ID',
        index=True,
        readonly=True,
        help='Home Assistant label ID (generated by HA)'
    )
    name = fields.Char(
        string='Name',
        required=True,
        index=True,
        help='Label name (synced with HA)'
    )
    ha_instance_id = fields.Many2one(
        'ha.instance',
        string='HA Instance',
        required=True,
        index=True,
        ondelete='cascade',
        help='The Home Assistant instance this label belongs to'
    )
    icon = fields.Char(
        string='Icon',
        help='Material Design Icon (e.g., mdi:tag)'
    )
    ha_color = fields.Char(
        string='HA Color',
        help='Color name from HA (e.g., red, blue, green)'
    )
    description = fields.Text(
        string='Description',
        help='Label description'
    )

    # Timestamps from HA
    created_at = fields.Float(
        string='Created At',
        readonly=True,
        help='Unix timestamp when label was created in HA'
    )
    modified_at = fields.Float(
        string='Modified At',
        readonly=True,
        help='Unix timestamp when label was last modified in HA'
    )

    # Odoo UI color (separate from HA color)
    color = fields.Integer(
        string='Color Index',
        default=0,
        help='Color index for display in Odoo UI'
    )

    # Reverse relations for easy lookup
    device_ids = fields.Many2many(
        'ha.device',
        'ha_device_label_rel',
        'label_id',
        'device_id',
        string='Devices',
        help='Devices with this label'
    )
    area_ids = fields.Many2many(
        'ha.area',
        'ha_area_label_rel',
        'label_id',
        'area_id',
        string='Areas',
        help='Areas with this label'
    )
    entity_ids = fields.Many2many(
        'ha.entity',
        'ha_entity_label_rel',
        'label_id',
        'entity_id',
        string='Entities',
        help='Entities with this label'
    )

    # Computed fields for statistics
    device_count = fields.Integer(
        string='Device Count',
        compute='_compute_device_count',
        help='Number of devices with this label'
    )
    area_count = fields.Integer(
        string='Area Count',
        compute='_compute_area_count',
        help='Number of areas with this label'
    )
    entity_count = fields.Integer(
        string='Entity Count',
        compute='_compute_entity_count',
        help='Number of entities with this label'
    )

    @api.depends('device_ids')
    def _compute_device_count(self):
        for label in self:
            label.device_count = len(label.device_ids)

    @api.depends('area_ids')
    def _compute_area_count(self):
        for label in self:
            label.area_count = len(label.area_ids)

    @api.depends('entity_ids')
    def _compute_entity_count(self):
        for label in self:
            label.entity_count = len(label.entity_ids)

    # ========== Bidirectional Sync: Odoo → HA ==========

    @api.model_create_multi
    def create(self, vals_list):
        """
        Override create: After creating label in Odoo, sync to HA

        Use context['from_ha_sync'] = True to prevent sync loop
        """
        records = super().create(vals_list)

        # If synced from HA, don't sync back
        if not self.env.context.get('from_ha_sync'):
            for record in records:
                try:
                    record._create_label_in_ha()
                except Exception as e:
                    _logger.error(f"Failed to sync label {record.name} to HA: {e}")

        return records

    def write(self, vals):
        """
        Override write: After updating label in Odoo, sync to HA

        Use context['from_ha_sync'] = True to prevent sync loop
        """
        result = super().write(vals)

        # If synced from HA, don't sync back
        if not self.env.context.get('from_ha_sync'):
            # Only sync if editable fields changed
            syncable_fields = {'name', 'icon', 'ha_color', 'description'}
            if any(field in vals for field in syncable_fields):
                for record in self:
                    try:
                        record._update_label_in_ha()
                    except Exception as e:
                        _logger.error(f"Failed to sync label update {record.name} to HA: {e}")

        return result

    def unlink(self):
        """
        Override unlink: Before deleting label, sync to HA

        Use context['from_ha_sync'] = True to prevent sync loop
        """
        # Backup label_id and instance_id for HA API call
        labels_to_delete = [(r.label_id, r.ha_instance_id.id, r.name) for r in self]

        result = super().unlink()

        # If synced from HA, don't sync back
        if not self.env.context.get('from_ha_sync'):
            for label_id, instance_id, name in labels_to_delete:
                if not label_id:
                    _logger.info(f"Skipping HA delete for label '{name}' - not synced to HA yet")
                    continue
                try:
                    self._delete_label_in_ha(label_id, instance_id)
                except Exception as e:
                    _logger.error(f"Failed to delete label {name} from HA: {e}")

        return result

    def _create_label_in_ha(self):
        """
        Create Label in HA using WebSocket API

        API: config/label_registry/create
        """
        self.ensure_one()

        if not self.ha_instance_id:
            _logger.warning(f"Cannot sync label {self.name}: no HA instance")
            return

        try:
            from odoo.addons.odoo_ha_addon.models.common.websocket_client import get_websocket_client
            client = get_websocket_client(self.env, instance_id=self.ha_instance_id.id)

            payload = {
                'name': self.name,
                'icon': self.icon or None,
                'color': self.ha_color or None,
                'description': self.description or None,
            }

            _logger.info(f"Creating label in HA: {self.name} (instance {self.ha_instance_id.id})")
            result = client.call_websocket_api_sync('config/label_registry/create', payload)

            if result and isinstance(result, dict):
                # Update Odoo with HA-generated label_id
                ha_label_id = result.get('label_id')
                if ha_label_id and ha_label_id != self.label_id:
                    self.with_context(from_ha_sync=True).write({
                        'label_id': ha_label_id,
                        'created_at': result.get('created_at', 0),
                        'modified_at': result.get('modified_at', 0),
                    })
                    _logger.info(f"Updated label_id from HA: {ha_label_id}")

            _logger.info(f"Label {self.name} created in HA successfully")

        except Exception as e:
            _logger.error(f"Failed to create label {self.name} in HA: {e}", exc_info=True)
            raise

    def _update_label_in_ha(self):
        """
        Update Label in HA using WebSocket API

        API: config/label_registry/update
        """
        self.ensure_one()

        if not self.ha_instance_id or not self.label_id:
            _logger.warning(f"Cannot sync label update {self.name}: missing HA instance or label_id")
            return

        try:
            from odoo.addons.odoo_ha_addon.models.common.websocket_client import get_websocket_client
            client = get_websocket_client(self.env, instance_id=self.ha_instance_id.id)

            payload = {
                'label_id': self.label_id,
                'name': self.name,
                'icon': self.icon or None,
                'color': self.ha_color or None,
                'description': self.description or None,
            }

            _logger.info(f"Updating label in HA: {self.name} (label_id={self.label_id})")
            client.call_websocket_api_sync('config/label_registry/update', payload)

            _logger.info(f"Label {self.name} updated in HA successfully")

        except Exception as e:
            _logger.error(f"Failed to update label {self.name} in HA: {e}", exc_info=True)
            raise

    @api.model
    def _delete_label_in_ha(self, label_id, instance_id):
        """
        Delete Label in HA using WebSocket API

        API: config/label_registry/delete

        Args:
            label_id: HA label_id
            instance_id: HA instance ID
        """
        if not label_id or not instance_id:
            _logger.warning(f"Cannot delete label: missing label_id or instance_id")
            return

        try:
            from odoo.addons.odoo_ha_addon.models.common.websocket_client import get_websocket_client
            client = get_websocket_client(self.env, instance_id=instance_id)

            payload = {'label_id': label_id}

            _logger.info(f"Deleting label in HA: {label_id} (instance {instance_id})")
            client.call_websocket_api_sync('config/label_registry/delete', payload)

            _logger.info(f"Label {label_id} deleted in HA successfully")

        except Exception as e:
            _logger.error(f"Failed to delete label {label_id} in HA: {e}", exc_info=True)
            raise

    # ========== Bidirectional Sync: HA → Odoo ==========

    @api.model
    def sync_label_from_ha_data(self, label_data, instance_id):
        """
        Unified method: Sync single label from HA data to Odoo

        This is the single entry point for HA → Odoo sync, called by:
        - WebSocket event handlers
        - Initial sync (batch)
        - Manual sync

        Args:
            label_data: HA label registry data dict
            instance_id: HA instance ID

        Returns:
            tuple: (action, label_record) - action is 'created', 'updated', or None
        """
        label_id = label_data.get('label_id')
        if not label_id:
            return None, None

        values = {
            'label_id': label_id,
            'name': label_data.get('name', ''),
            'icon': label_data.get('icon'),
            'ha_color': label_data.get('color'),
            'description': label_data.get('description'),
            'created_at': label_data.get('created_at', 0),
            'modified_at': label_data.get('modified_at', 0),
            'ha_instance_id': instance_id,
        }

        existing_label = self.sudo().search([
            ('label_id', '=', label_id),
            ('ha_instance_id', '=', instance_id)
        ], limit=1)

        # Use from_ha_sync to prevent reverse sync loop
        if existing_label:
            existing_label.with_context(from_ha_sync=True).write(values)
            return 'updated', existing_label
        else:
            new_label = self.sudo().with_context(from_ha_sync=True).create(values)
            return 'created', new_label

    @api.model
    def get_or_create_labels(self, label_ids, instance_id):
        """
        Get or create labels by HA label_ids for a specific HA instance.

        Note: In HA, device/area labels are stored as label_id references,
        not label names. This method looks up by label_id.

        If a label_id doesn't exist in Odoo, it means the label hasn't been
        synced yet. We just skip it (it will be synced on next label sync).

        Args:
            label_ids: List of HA label_ids (strings)
            instance_id: HA instance ID

        Returns:
            recordset of ha.label records
        """
        if not label_ids:
            return self.browse()

        # Simply search for existing labels by label_id
        labels = self.sudo().search([
            ('label_id', 'in', label_ids),
            ('ha_instance_id', '=', instance_id)
        ])

        # Log if some labels are missing (they should be synced from HA)
        found_ids = set(labels.mapped('label_id'))
        missing_ids = set(label_ids) - found_ids
        if missing_ids:
            _logger.debug(
                f"Labels not found in Odoo (will be synced later): {missing_ids} "
                f"for instance {instance_id}"
            )

        return labels

    @api.model
    def sync_labels_from_ha(self, instance_id=None):
        """
        Sync all labels from Home Assistant

        Uses WebSocket API: config/label_registry/list

        Args:
            instance_id: HA instance ID, if None uses HAInstanceHelper
        """
        _logger.info(f"=== Starting sync_labels_from_ha (instance_id={instance_id}) ===")

        try:
            if instance_id is None:
                from odoo.addons.odoo_ha_addon.models.common.instance_helper import HAInstanceHelper
                instance_id = HAInstanceHelper.get_current_instance(self.env, logger=_logger)
                if not instance_id:
                    _logger.error("No HA instance available")
                    return

            from odoo.addons.odoo_ha_addon.models.common.websocket_client import get_websocket_client
            client = get_websocket_client(self.env, instance_id=instance_id)

            result = client.call_websocket_api_sync('config/label_registry/list', {})

            if not result or not isinstance(result, list):
                _logger.warning("No labels received from Home Assistant or invalid format")
                return

            _logger.info(f"Received {len(result)} labels from Home Assistant (instance {instance_id})")

            # Batch process labels
            created_count = 0
            updated_count = 0

            for label_data in result:
                try:
                    action, _ = self.sync_label_from_ha_data(label_data, instance_id)
                    if action == 'created':
                        created_count += 1
                    elif action == 'updated':
                        updated_count += 1
                except Exception as e:
                    _logger.error(f"Error processing label {label_data.get('label_id')}: {e}")

            _logger.info(f"Label sync (instance {instance_id}): {created_count} created, {updated_count} updated")
            _logger.info("=== sync_labels_from_ha completed ===")

        except Exception as e:
            _logger.error(f"Failed to sync labels: {e}", exc_info=True)
