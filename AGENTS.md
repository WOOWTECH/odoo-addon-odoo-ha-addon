# 代理

專門處理繁重工作的代理，回傳簡潔摘要以保留上下文。

## 核心理念

> "不要將子代理擬人化。使用它們來組織你的提示並省略上下文。當子代理能夠完成大量工作但只向主執行緒提供少量資訊時效果最佳。"
>
> – Adam Wolff, Anthropic

## 可用代理

### 🔍 `code-analyzer`

- **目的**: 跨多個檔案查找錯誤而不汙染主執行緒上下文
- **模式**: 搜尋多個檔案 → 分析程式碼 → 回傳錯誤報告
- **用法**: 當你需要追蹤邏輯流、查找錯誤或驗證變更時
- **回傳**: 僅包含關鍵發現的簡潔錯誤報告

### 📄 `file-analyzer`

- **目的**: 讀取和總結詳細檔案（日誌、輸出、設定）
- **模式**: 讀取檔案 → 提取見解 → 回傳摘要
- **用法**: 當你需要理解日誌檔案或分析詳細輸出時
- **回傳**: 關鍵發現和可操作的見解（減少 80-90% 的大小）

### 🧪 `test-runner`

- **目的**: 執行測試而不將輸出傾印到主執行緒
- **模式**: 執行測試 → 擷取到日誌 → 分析結果 → 回傳摘要
- **用法**: 當你需要執行測試並理解失敗原因時
- **回傳**: 包含失敗分析的測試結果摘要

### 🔀 `parallel-worker`

- **目的**: 協調處理問題的多個並行工作流
- **模式**: 讀取分析 → 產生子代理 → 整合結果 → 回傳摘要
- **用法**: 當在工作樹中執行並行工作流時
- **回傳**: 所有並行工作的整合狀態

## 為什麼使用代理？

代理是保護主執行緒免受資訊過載的**上下文防火牆**：

```
不使用代理：
主執行緒讀取 10 個檔案 → 上下文爆炸 → 失去連貫性

使用代理：
代理讀取 10 個檔案 → 主執行緒獲得 1 個摘要 → 上下文得以保留
```

## 代理如何保留上下文

1. **繁重工作** - 代理完成繁瑣的工作（讀取檔案、執行測試、實作功能）
2. **上下文隔離** - 實作細節保留在代理中，不在主執行緒
3. **簡潔回傳** - 只有必要資訊回傳到主執行緒對話
4. **並行執行** - 多個代理可以同時工作而不會產生上下文衝突

## 使用範例

```bash
# 分析程式碼查找錯誤
任務: "在程式碼庫中搜尋記憶體洩漏"
代理: code-analyzer
回傳: "發現 3 個潛在洩漏: [簡潔列表]"
主執行緒不會看到: 檢查的數百個檔案

# 執行測試
任務: "執行身份驗證測試"
代理: test-runner
回傳: "10 個測試中有 2 個失敗: [失敗摘要]"
主執行緒不會看到: 詳細的測試輸出和日誌

# 並行實作
任務: "使用並行流實作問題 #1234"
代理: parallel-worker
回傳: "完成 4/4 個流，修改了 15 個檔案"
主執行緒不會看到: 單個實作細節
```

## 建立新代理

新代理應遵循以下原則：

1. **單一目的** - 每個代理都有一個明確的工作
2. **上下文縮減** - 回傳處理內容的 10-20%
3. **不角色扮演** - 代理不是「專家」，而是任務執行器
4. **清晰模式** - 定義輸入 → 處理 → 輸出模式
5. **錯誤處理** - 優雅地處理失敗並清晰報告

## 需避免的反模式

❌ **建立「專家」代理**（資料庫專家、API 專家）
代理沒有不同的知識 - 它們都是相同的模型

❌ **回傳詳細輸出**
違背了上下文保留的目的

❌ **讓代理相互溝通**
應該使用協調代理（如 parallel-worker）

❌ **為簡單任務使用代理**
只有當上下文縮減有價值時才使用代理

## 與 PM 系統的整合

代理與 PM 命令系統無縫整合：

- `/pm:issue-analyze` → 識別工作流
- `/pm:issue-start` → 產生 parallel-worker 代理
- parallel-worker → 產生多個子代理
- 子代理 → 在工作樹中並行工作
- 結果 → 整合回主執行緒

這建立了一個層次結構，在每個層級都最大化並行性同時保留上下文。
